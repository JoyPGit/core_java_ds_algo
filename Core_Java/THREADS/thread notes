THREE WAYS :

1 THREADS SYNCHRONIZED
2 SEMPAHORES
3 BLOCKING QUEUES

start, sleep, wait, lock, notify

start -> thread starts, t = new Thread( obj, "thread_name"); t.start();

wait -> forces the current thread to wait until some other thread invokes notify() or notifyAll() 
on the same object; makes thread relinquish the lock

notify -> notifies other threads; Since notify() wakes up a single random thread it can be 
used to implement mutually exclusive locking where threads are doing similar tasks, 
but in most cases, it would be more viable to implement notifyAll().

lock


---------------------------------------------------------------
A Java synchronized block marks a method or a block of code as synchronized. 
A synchronized block in Java can only be executed as a single thread at a time (depending on how you use it). 
Java synchronized blocks can thus be used to avoid race conditions.

The synchronized keyword can be used to mark four different types of blocks:

Instance methods
Static methods
Code blocks inside instance methods
Code blocks inside static methods


http://tutorials.jenkov.com/java-concurrency/synchronized.html

synchronized void printOdd(int number) {
    while (isOdd) {
        try {
            System.out.println("before wait");
            wait();
            System.out.println("after wait");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    System.out.println(Thread.currentThread().getName() + " : " + number);
    isOdd = true;
    notify();
    
}

Volatile keyword is used to modify the value of a variable by different threads. 
It is also used to make classes thread safe. It means that multiple threads can use a 
method and instance of the classes at the same time without any problem.

* The awakened thread will not be able to proceed until the current thread 
* relinquishes the lock on this object. Hence thread enters while loop.
* 'wait' makes it relinquish the lock.

----------------------------------------------------------
Should i use synchronized in each thread class
or use a single synchronized method and make threads access it?

* Producer-Consumer uses 2 synchronized methods
* for printing even odd, also used 2

but for synchronized to work a critical resource is required, either
the synchronized block beomes the critical resource or a common 
no primitive data structure is chosen.


----------------------------------------------------------


----------------------------------------------------------
ERRORS :

Syntax error, insert "... VariableDeclaratorId" to complete FormalParameterList

You can't have arbitrary code like that directly in the class body. 
It must be in a method (or constructor, or initialization block).


executor framework
join

concurrent hashmap vs hashmap
future

44

ConcurrentHashMap has :

1 Multiple partitions which can be locked independently. (16 by default)
2 Using concurrent Locks operations for thread safety instead of synchronized.
3 Has thread safe Iterators. synchronizedCollection's iterators are not thread safe.
4 Does not expose the internal locks. synchronizedCollection does.

ConcurrentHashMap does not lock the Map while you are reading from it. 
Additionally,ConcurrentHashMap does not lock the entire Mapwhen writing to it. 
It only locks the part of the Map that is being written to, internally.

Hashtable’s offer concurrent access to their entries, with a small caveat, 
the entire map is locked to perform any sort of operation. While this overhead is ignorable in a web 
application under normal load, under heavy load it can lead to delayed response times and 
overtaxing of your server for no good reason.

This is where ConcurrentHashMap’s step in. They offer all the features of Hashtable with a 
performance almost as good as a HashMap. ConcurrentHashMap’s accomplish this by a very simple mechanism. 
Instead of a map wide lock, the collection maintains a list of 16 locks by default, each of which is 
used to guard (or lock on) a single bucket of the map. This effectively means that 16 threads can 
modify the collection at a single time (as long as they’re all working on different buckets). 
Infact there is no operation performed by this collection that locks the entire map. 
The concurrency level of the collection, the number of threads that can modify it at the same time 
without blocking, can be increased. However a higher number means more overhead of maintaining this list of locks.
